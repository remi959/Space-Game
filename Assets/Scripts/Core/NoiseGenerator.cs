using UnityEngine;

/// <summary>
/// Noise generation utilities for procedural terrain.
/// Uses layered Simplex noise for natural-looking terrain.
/// </summary>
public static class NoiseGenerator
{
    /// <summary>
    /// Settings for noise generation.
    /// </summary>
    [System.Serializable]
    public class NoiseSettings
    {
        [Tooltip("Number of noise layers (more = more detail)")]
        /// <summary>
        /// Number of noise layers (more = more detail)
        /// </summary>
        public int octaves = 4;

        [Tooltip("How much detail is added each octave (typically 2)")]
        /// <summary>
        /// How much detail is added each octave (typically 2)
        /// </summary>
        public float lacunarity = 2f;

        [Tooltip("How much each octave contributes (typically 0.5)")]
        [Range(0f, 1f)]
        /// <summary>
        /// How much each octave contributes (typically 0.5)
        /// </summary>
        public float persistence = 0.5f;

        [Tooltip("Base scale of the noise")]
        /// <summary>
        /// Base scale of the noise
        /// Decides the "zoom" level of the noise which affects feature size.
        /// </summary>
        public float scale = 50f;

        [Tooltip("Strength of the noise effect")]
        /// <summary>
        /// Strength of the noise effect
        /// Multiplies the final noise value to increase/decrease terrain variation.
        /// </summary>
        public float strength = 1f;

        [Tooltip("Minimum value output")]
        public float minValue = 0f;

        [Tooltip("Offset for the noise sampling")]
        public Vector3 offset = Vector3.zero;
    }

    /// <summary>
    /// Samples 3D noise at a given point using layered Simplex noise.
    /// </summary>
    /// <param name="point">World position to sample</param>
    /// <param name="settings">Noise configuration</param>
    /// <param name="seed">Random seed for variation</param>
    /// <returns>Noise value (typically -1 to 1, but can exceed with multiple octaves)</returns>
    public static float Sample3D(Vector3 point, NoiseSettings settings, int seed = 0)
    {
        float noiseValue = 0f;
        float frequency = 1f;
        float amplitude = 1f;
        float maxPossibleValue = 0f;

        Vector3 seedOffset = HashUtility.GetSeedOffset(seed);

        for (int i = 0; i < settings.octaves; i++)
        {
            // Sample position with scale, frequency, and offsets applied
            float sampleX = (point.x + settings.offset.x + seedOffset.x) / settings.scale * frequency;
            float sampleY = (point.y + settings.offset.y + seedOffset.y) / settings.scale * frequency;
            float sampleZ = (point.z + settings.offset.z + seedOffset.z) / settings.scale * frequency;

            // Get noise value at this octave
            float sample = Simplex3D(sampleX, sampleY, sampleZ);

            noiseValue += sample * amplitude;
            maxPossibleValue += amplitude;

            // Prepare for next octave
            amplitude *= settings.persistence;
            frequency *= settings.lacunarity;
        }

        // Normalize to roughly -1 to 1 range
        noiseValue /= maxPossibleValue;

        // Apply strength and minimum value
        noiseValue = noiseValue * settings.strength;
        noiseValue = Mathf.Max(noiseValue, settings.minValue);

        return noiseValue;
    }

    /// <summary>
    /// Samples noise for a spherical surface (useful for planet terrain height).
    /// </summary>
    /// <param name="pointOnSphere">Normalized point on unit sphere</param>
    /// <param name="settings">Noise configuration</param>
    /// <param name="seed">Random seed</param>
    /// <returns>Height offset value</returns>
    public static float SampleSphere(Vector3 pointOnSphere, NoiseSettings settings, int seed = 0)
    {
        // Use the sphere point directly as noise coordinates
        // This ensures seamless wrapping around the sphere
        return Sample3D(pointOnSphere * settings.scale, settings, seed);
    }

    // =========================================================================
    // SIMPLEX NOISE IMPLEMENTATION
    // Based on Stefan Gustavson's implementation
    // =========================================================================

    /// <summary>
    /// Permutation table for Simplex noise.
    /// Used to hash coordinates.
    /// It works by indexing into this table to get gradient indices.
    /// Gradients are then selected from a predefined set. 
    /// Then dot products are computed to get noise contributions.
    /// Noise is generated by combining these contributions.
    /// </summary>
    private static readonly int[] perm = {
        151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,
        8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,
        35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,
        134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,
        55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,
        18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,
        250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,
        189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,
        172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,
        228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,
        107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,
        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,
        151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,
        8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,
        35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,
        134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,
        55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,
        18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,
        250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,
        189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,
        172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,
        228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,
        107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,
        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180
    };

    private static readonly Vector3[] grad3 = {
        new(1,1,0), new(-1,1,0), new(1,-1,0), new(-1,-1,0),
        new(1,0,1), new(-1,0,1), new(1,0,-1), new(-1,0,-1),
        new(0,1,1), new(0,-1,1), new(0,1,-1), new(0,-1,-1)
    };

    private static float Dot(Vector3 g, float x, float y, float z)
    {
        return g.x * x + g.y * y + g.z * z;
    }

    /// <summary>
    /// 3D Simplex noise implementation.
    /// Returns value in range [-1, 1].
    /// </summary>
    public static float Simplex3D(float x, float y, float z)
    {
        // Skewing factors for 3D
        const float F3 = 1.0f / 3.0f;
        const float G3 = 1.0f / 6.0f;

        float n0, n1, n2, n3;

        // Skew input space to determine simplex cell
        float s = (x + y + z) * F3;
        int i = Mathf.FloorToInt(x + s);
        int j = Mathf.FloorToInt(y + s);
        int k = Mathf.FloorToInt(z + s);

        float t = (i + j + k) * G3;
        float X0 = i - t;
        float Y0 = j - t;
        float Z0 = k - t;
        float x0 = x - X0;
        float y0 = y - Y0;
        float z0 = z - Z0;

        // Determine which simplex we're in
        int i1, j1, k1;
        int i2, j2, k2;

        if (x0 >= y0)
        {
            if (y0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0; }
            else if (x0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1; }
            else { i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1; }
        }
        else
        {
            if (y0 < z0) { i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1; }
            else if (x0 < z0) { i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1; }
            else { i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0; }
        }

        float x1 = x0 - i1 + G3;
        float y1 = y0 - j1 + G3;
        float z1 = z0 - k1 + G3;
        float x2 = x0 - i2 + 2.0f * G3;
        float y2 = y0 - j2 + 2.0f * G3;
        float z2 = z0 - k2 + 2.0f * G3;
        float x3 = x0 - 1.0f + 3.0f * G3;
        float y3 = y0 - 1.0f + 3.0f * G3;
        float z3 = z0 - 1.0f + 3.0f * G3;

        int ii = i & 255;
        int jj = j & 255;
        int kk = k & 255;

        int gi0 = perm[ii + perm[jj + perm[kk]]] % 12;
        int gi1 = perm[ii + i1 + perm[jj + j1 + perm[kk + k1]]] % 12;
        int gi2 = perm[ii + i2 + perm[jj + j2 + perm[kk + k2]]] % 12;
        int gi3 = perm[ii + 1 + perm[jj + 1 + perm[kk + 1]]] % 12;

        // Calculate contributions from corners
        float t0 = 0.6f - x0 * x0 - y0 * y0 - z0 * z0;
        if (t0 < 0) n0 = 0.0f;
        else
        {
            t0 *= t0;
            n0 = t0 * t0 * Dot(grad3[gi0], x0, y0, z0);
        }

        float t1 = 0.6f - x1 * x1 - y1 * y1 - z1 * z1;
        if (t1 < 0) n1 = 0.0f;
        else
        {
            t1 *= t1;
            n1 = t1 * t1 * Dot(grad3[gi1], x1, y1, z1);
        }

        float t2 = 0.6f - x2 * x2 - y2 * y2 - z2 * z2;
        if (t2 < 0) n2 = 0.0f;
        else
        {
            t2 *= t2;
            n2 = t2 * t2 * Dot(grad3[gi2], x2, y2, z2);
        }

        float t3 = 0.6f - x3 * x3 - y3 * y3 - z3 * z3;
        if (t3 < 0) n3 = 0.0f;
        else
        {
            t3 *= t3;
            n3 = t3 * t3 * Dot(grad3[gi3], x3, y3, z3);
        }

        // Scale to [-1, 1]
        return 32.0f * (n0 + n1 + n2 + n3);
    }
}